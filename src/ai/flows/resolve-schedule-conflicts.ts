
// This is an autogenerated file from Firebase Studio.
'use server';

/**
 * @fileOverview Implements the ResolveScheduleConflicts flow to detect and resolve scheduling conflicts.
 *
 * - resolveScheduleConflicts - A function that handles the conflict resolution process.
 * - ResolveScheduleConflictsInput - The input type for the resolveScheduleConflicts function.
 * - ResolveScheduleConflictsOutput - The return type for the resolveScheduleConflicts function.
 */

import {ai} from '@/ai/genkit';
import {z} from 'genkit';

const ResolveScheduleConflictsInputSchema = z.object({
  schedules: z.string().describe('A list of schedules to check for conflicts, in JSON format.'),
  parameters: z.string().optional().describe('Additional parameters including classes, subjects, and faculty, in JSON format.'),
});
export type ResolveScheduleConflictsInput = z.infer<typeof ResolveScheduleConflictsInputSchema>;

const ResolveScheduleConflictsOutputSchema = z.object({
  hasConflicts: z.boolean().describe('Whether or not any conflicts were detected.'),
  resolvedSchedules: z.string().describe('The schedules with conflicts resolved, in JSON format. This should be the full schedule, not just the changed parts.'),
  conflictDetails: z.string().optional().describe('Details about the detected conflicts, in JSON format.'),
});
export type ResolveScheduleConflictsOutput = z.infer<typeof ResolveScheduleConflictsOutputSchema>;

export async function resolveScheduleConflicts(input: ResolveScheduleConflictsInput): Promise<ResolveScheduleConflictsOutput> {
  return resolveScheduleConflictsFlow(input);
}

const resolveScheduleConflictsPrompt = ai.definePrompt({
  name: 'resolveScheduleConflictsPrompt',
  input: {schema: ResolveScheduleConflictsInputSchema},
  output: {schema: ResolveScheduleConflictsOutputSchema},
  prompt: `You are an AI assistant specialized in resolving university class scheduling conflicts.

Your task is to identify and resolve any conflicts in the provided schedule. A conflict occurs if:
1.  A faculty member is scheduled for two different classes at the same time.
2.  A class is scheduled for two different subjects at the same time.

You will receive the current schedule, plus lists of all available classes, subjects, and faculty members.

Schedules: {{{schedules}}}
Parameters: {{{parameters}}}

Your goals are:
1.  **Detect Conflicts:** Analyze the schedule to find all instances of conflicts.
2.  **Generate Details:** If conflicts are found, provide a clear, human-readable JSON object in 'conflictDetails' explaining each conflict (who, what, when, and where).
3.  **Resolve Conflicts:** Create a new, complete schedule in 'resolvedSchedules' that resolves all conflicts.
    *   You should make the minimum number of changes necessary.
    *   You can reassign faculty or change time slots for conflicting classes.
    *   Do not remove any classes from the schedule. Every class must be taught.
    *   The resolved schedule must be a complete, valid JSON array of all schedule slots, not just the ones you changed.
4.  **Set Flag:** Set 'hasConflicts' to true if conflicts were found, and false otherwise.

If no conflicts are found, 'hasConflicts' should be false, 'resolvedSchedules' should be the original schedule, and 'conflictDetails' can be an empty object.

Ensure all JSON outputs ('resolvedSchedules', 'conflictDetails') are valid.
`,
});

const resolveScheduleConflictsFlow = ai.defineFlow(
  {
    name: 'resolveScheduleConflictsFlow',
    inputSchema: ResolveScheduleConflictsInputSchema,
    outputSchema: ResolveScheduleConflictsOutputSchema,
  },
  async input => {
    try {
      JSON.parse(input.schedules);
      if (input.parameters) {
        JSON.parse(input.parameters);
      }
    } catch (e: any) {
      throw new Error('Invalid JSON format in schedules or parameters: ' + e.message);
    }

    const {output} = await resolveScheduleConflictsPrompt(input);
    return output!;
  }
);
