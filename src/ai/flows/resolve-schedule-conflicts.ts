
// This is an autogenerated file from Firebase Studio.
'use server';

/**
 * @fileOverview Implements the ResolveScheduleConflicts flow to detect and resolve scheduling conflicts.
 *
 * - resolveScheduleConflicts - A function that handles the conflict resolution process.
 * - ResolveScheduleConflictsInput - The input type for the resolveScheduleConflicts function.
 * - ResolveScheduleConflictsOutput - The return type for the resolveScheduleConflicts function.
 */

import {ai} from '@/ai/genkit';
import {z} from 'genkit';

const ResolveScheduleConflictsInputSchema = z.object({
  schedules: z.string().describe('A list of schedules to check for conflicts, in JSON format.'),
  parameters: z.string().optional().describe('Additional parameters including classes, subjects, faculty, and classrooms, in JSON format.'),
});
export type ResolveScheduleConflictsInput = z.infer<typeof ResolveScheduleConflictsInputSchema>;

const ResolveScheduleConflictsOutputSchema = z.object({
  hasConflicts: z.boolean().describe('Whether or not any conflicts were detected.'),
  resolvedSchedules: z.string().describe('The schedules with conflicts resolved, in JSON format. This should be the full schedule, not just the changed parts.'),
  conflictDetails: z.string().optional().describe('Details about the detected conflicts, in JSON format.'),
});
export type ResolveScheduleConflictsOutput = z.infer<typeof ResolveScheduleConflictsOutputSchema>;

export async function resolveScheduleConflicts(input: ResolveScheduleConflictsInput): Promise<ResolveScheduleConflictsOutput> {
  return resolveScheduleConflictsFlow(input);
}

const resolveScheduleConflictsPrompt = ai.definePrompt({
  name: 'resolveScheduleConflictsPrompt',
  input: {schema: ResolveScheduleConflictsInputSchema},
  output: {schema: ResolveScheduleConflictsOutputSchema},
  prompt: `You are an AI assistant specialized in resolving university class scheduling conflicts.

Your task is to identify and resolve any conflicts in the provided schedule JSON. A conflict occurs if:
1.  A faculty member is scheduled for two different classes at the same time.
2.  A class is scheduled for two different subjects at the same time.
3.  A classroom is booked for two different classes at the same time.

You will receive the current schedule and all available parameters as JSON strings.

**Schedules JSON Structure:**
\`\`\`json
[
  {
    "id": "SCH001",
    "classId": "CLS004",
    "subjectId": "SUB005",
    "facultyId": "FAC001",
    "classroomId": "CR001",
    "day": "Monday",
    "time": "09:00 - 10:00"
  },
  ...
]
\`\`\`
Schedules: {{{schedules}}}


**Parameters JSON Structure:**
\`\`\`json
{
  "classes": [{"id": "CLS001", "name": "FE COMP", ...}],
  "subjects": [{"id": "SUB001", "name": "Intro to CS", ...}],
  "faculty": [{"id": "FAC001", "name": "Dr. Turing", ...}],
  "classrooms": [{"id": "CR001", "name": "Room 101", ...}],
  "constraints": {
    "faculty": { "max_classes_per_day": 4, "max_classes_per_week": 10 },
    "class": { "max_classes_per_day": 5 }
  }
}
\`\`\`
Parameters: {{{parameters}}}


Your goals are:
1.  **Detect Conflicts:** Analyze the schedule to find all instances of conflicts based on the rules above.
2.  **Generate Details:** If conflicts are found, provide a clear, human-readable JSON object in 'conflictDetails' explaining each conflict (who/what, when, and where).
3.  **Resolve Conflicts:** Create a new, complete schedule in 'resolvedSchedules' that resolves all conflicts.
    *   You must make the minimum number of changes necessary.
    *   You can reassign faculty, change time slots, or change classrooms for conflicting classes.
    *   Do not remove any classes from the schedule. Every class must be taught.
    *   The resolved schedule must be a complete, valid JSON array of all schedule slots, not just the ones you changed.
    *   The resolution must respect all workload constraints provided in the parameters (max classes per day/week for faculty and classes).
4.  **Set Flag:** Set 'hasConflicts' to true if conflicts were found, and false otherwise.

If no conflicts are found, 'hasConflicts' should be false, 'resolvedSchedules' should be the original schedule, and 'conflictDetails' can be an empty object.

Ensure all JSON outputs ('resolvedSchedules', 'conflictDetails') are valid.
`,
});

const resolveScheduleConflictsFlow = ai.defineFlow(
  {
    name: 'resolveScheduleConflictsFlow',
    inputSchema: ResolveScheduleConflictsInputSchema,
    outputSchema: ResolveScheduleConflictsOutputSchema,
  },
  async input => {
    try {
      JSON.parse(input.schedules);
      if (input.parameters) {
        JSON.parse(input.parameters);
      }
    } catch (e: any) {
      throw new Error('Invalid JSON format in schedules or parameters: ' + e.message);
    }

    const {output} = await resolveScheduleConflictsPrompt(input);
    return output!;
  }
);
